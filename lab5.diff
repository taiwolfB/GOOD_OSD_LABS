diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
index 6cf5bcc..88ab994 100644
--- a/src/HAL9000/src/system.c
+++ b/src/HAL9000/src/system.c
@@ -59,10 +59,22 @@ SystemPreinit(
     ProcessSystemPreinit();
 }
 
+static
 STATUS
-SystemInit(
-    IN  ASM_PARAMETERS*     Parameters
+(__cdecl _HelloIpi)(
+    IN_OPT PVOID Context
     )
+{
+    UNREFERENCED_PARAMETER(Context);
+
+    LOGP("Hello from CPU with ApicId %x\n", GetCurrentPcpu()->ApicId);
+    return STATUS_SUCCESS;
+}
+
+STATUS
+SystemInit(
+    IN  ASM_PARAMETERS* Parameters
+)
 {
     STATUS status;
     PCPU* pCpu;
@@ -71,9 +83,9 @@ SystemInit(
     pCpu = NULL;
 
     LogSystemInit(LogLevelInfo,
-                  LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-                  TRUE
-                  );
+        LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
+        TRUE
+    );
 
     // if validation fails => the system will HALT
     CpuMuValidateConfiguration();
@@ -101,7 +113,7 @@ SystemInit(
         OsGetBuildType(),
         OsGetVersion(),
         OsGetBuildDate()
-        );
+    );
 
     status = OsInfoInit();
     if (!SUCCEEDED(status))
@@ -134,10 +146,10 @@ SystemInit(
     LOGL("InitIdtHandlers succeeded\n");
 
     status = MmuInitSystem(Parameters->KernelBaseAddress,
-                           (DWORD) Parameters->KernelSize,
-                           Parameters->MemoryMapAddress,
-                           Parameters->MemoryMapEntries
-                           );
+        (DWORD)Parameters->KernelSize,
+        Parameters->MemoryMapAddress,
+        Parameters->MemoryMapEntries
+    );
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("MmuInitSystem", status);
@@ -149,7 +161,7 @@ SystemInit(
     if (IsBooleanFlagOn(Parameters->MultibootInformation->Flags, MULTIBOOT_FLAG_BOOT_MODULES_PRESENT))
     {
         status = BootModulesInit((PHYSICAL_ADDRESS)(QWORD)Parameters->MultibootInformation->ModuleAddress,
-                                Parameters->MultibootInformation->ModuleCount);
+            Parameters->MultibootInformation->ModuleCount);
         if (!SUCCEEDED(status))
         {
             LOG_FUNC_ERROR("BootModulesMap", status);
@@ -195,12 +207,12 @@ SystemInit(
     // this needs to be before the call to IomuInitSystem because
     // by the time we enable interrupts we want our TSS descriptor to be installed
     status = CpuMuAllocAndInitCpu(&pCpu,
-    // C28039: The type of actual parameter 'CpuGetApicId()' should exactly match the type 'APIC_ID'
+        // C28039: The type of actual parameter 'CpuGetApicId()' should exactly match the type 'APIC_ID'
 #pragma warning(suppress: 28039)
-                                  CpuGetApicId(),
-                                  STACK_DEFAULT_SIZE,
-                                  m_systemData.NumberOfTssStacks
-                                  );
+        CpuGetApicId(),
+        STACK_DEFAULT_SIZE,
+        m_systemData.NumberOfTssStacks
+    );
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("CpuMuAllocAndInitCpu", status);
@@ -210,7 +222,7 @@ SystemInit(
 
     // initialize IO system
     // this also initializes the IDT
-    status = IomuInitSystem(GdtMuGetCS64Supervisor(),m_systemData.NumberOfTssStacks );
+    status = IomuInitSystem(GdtMuGetCS64Supervisor(), m_systemData.NumberOfTssStacks);
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("IomuInitSystem", status);
@@ -288,7 +300,7 @@ SystemInit(
     status = MmuInitThreadingSystem();
     if (!SUCCEEDED(status))
     {
-        LOG_FUNC_ERROR("MmuInitThreadingSystem", status );
+        LOG_FUNC_ERROR("MmuInitThreadingSystem", status);
         return status;
     }
 
@@ -313,6 +325,69 @@ SystemInit(
 
     LOGL("Network stack successfully initialized\n");
 
+    // Part I a) When HAL9000 boots, an IPI will be sent to all the CPUs except himself, 
+    //           which will LOG the "Hello" Message. The last parameter
+    //           tells the function if it should wait for the handling completion 
+    //           before returning. If we change the last parameter to TRUE, 
+    //           then the Tests present in Tests module will execute after IPI was handled.
+    // status = SmpSendGenericIpi(_HelloIpi, NULL, NULL, NULL, FALSE);
+    // if (!SUCCEEDED(status))
+    // {
+    //    LOG_FUNC_ERROR("SmpSendGenericIpi", status);
+    //    return status;
+    // }
+
+    // Part I d)
+
+    // SMP_DESTINATION dest = { 0 };
+    // status = SmpSendGenericIpiEx(_HelloIpi, NULL, NULL, NULL, TRUE, SmpIpiSendToAllIncludingSelf, dest);
+
+    // if (!SUCCEEDED(status))
+    // {
+    //     LOG_FUNC_ERROR("SmpSendGenericIpi", status);
+    //     return status;
+    // }
+
+
+    // Part I e)
+
+    // SMP_DESTINATION dest = { SmpGetNumberOfActiveCpus() - 1 };
+    // status = SmpSendGenericIpiEx(_HelloIpi, NULL, NULL, NULL, TRUE, SmpIpiSendToCpu, dest);
+
+    // if (!SUCCEEDED(status))
+    // {
+    //     LOG_FUNC_ERROR("SmpSendGenericIpi", status);
+    //     return status;
+    // }
+
+
+    // Part I f
+
+    SMP_DESTINATION dest;
+    memzero(&dest, sizeof(SMP_DESTINATION));
+    CPU_AFFINITY logicalAddressCurrentCpu = 1;
+    for (DWORD i = 1; i < SmpGetNumberOfActiveCpus(); i++)
+    {
+        // compute logical address of the current CPU by bit shifting
+        logicalAddressCurrentCpu <<= 1;
+        LOGP("Affinity %x\n", logicalAddressCurrentCpu);
+        // if the current cpu is an odd one in the physical address, 
+        // do an or between logical addresses of the logical address 
+        // of the current cpu and the group affinity
+        // if not, do an or with 0 such that the answer does not change
+        dest.Group.Affinity |= i % 2 == 1 ? logicalAddressCurrentCpu : 0;
+    }
+
+    status = SmpSendGenericIpiEx(_HelloIpi, NULL, NULL, NULL, TRUE, SmpIpiSendToGroup, dest);
+
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SmpSendGenericIpi", status);
+        return status;
+    }
+
+
+
     return status;
 }
 
diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
index 3ec2095..83ac463 100644
--- a/src/HAL9000/src/thread.c
+++ b/src/HAL9000/src/thread.c
@@ -19,7 +19,7 @@ extern void ThreadStart();
 typedef
 void
 (__cdecl FUNC_ThreadSwitch)(
-    OUT_PTR         PVOID*          OldStack,
+    OUT_PTR         PVOID* OldStack,
     IN              PVOID           NewStack
     );
 
@@ -30,13 +30,13 @@ typedef struct _THREAD_SYSTEM_DATA
     LOCK                AllThreadsLock;
 
     _Guarded_by_(AllThreadsLock)
-    LIST_ENTRY          AllThreadsList;
+        LIST_ENTRY          AllThreadsList;
 
     LOCK                ReadyThreadsLock;
 
     _Guarded_by_(ReadyThreadsLock)
-    LIST_ENTRY          ReadyThreadsList;
-} THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
+        LIST_ENTRY          ReadyThreadsList;
+} THREAD_SYSTEM_DATA, * PTHREAD_SYSTEM_DATA;
 
 static THREAD_SYSTEM_DATA m_threadSystemData;
 
@@ -45,7 +45,7 @@ static
 TID
 _ThreadSystemGetNextTid(
     void
-    )
+)
 {
     static volatile TID __currentTid = 0;
 
@@ -55,11 +55,11 @@ _ThreadSystemGetNextTid(
 static
 STATUS
 _ThreadInit(
-    IN_Z        char*               Name,
+    IN_Z        char* Name,
     IN          THREAD_PRIORITY     Priority,
-    OUT_PTR     PTHREAD*            Thread,
+    OUT_PTR     PTHREAD* Thread,
     IN          BOOLEAN             AllocateKernelStack
-    );
+);
 
 static
 STATUS
@@ -69,15 +69,15 @@ _ThreadSetupInitialState(
     IN      QWORD               FirstArgument,
     IN      QWORD               SecondArgument,
     IN      BOOLEAN             KernelStack
-    );
+);
 
 static
 STATUS
 _ThreadSetupMainThreadUserStack(
     IN      PVOID               InitialStack,
-    OUT     PVOID*              ResultingStack,
+    OUT     PVOID* ResultingStack,
     IN      PPROCESS            Process
-    );
+);
 
 
 REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
@@ -86,14 +86,14 @@ static
 void
 _ThreadSchedule(
     void
-    );
+);
 
 REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
 RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_threadSystemData.ReadyThreadsLock)
 void
 ThreadCleanupPostSchedule(
     void
-    );
+);
 
 REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
 static
@@ -101,25 +101,25 @@ _Ret_notnull_
 PTHREAD
 _ThreadGetReadyThread(
     void
-    );
+);
 
 static
 void
 _ThreadForcedExit(
     void
-    );
+);
 
 static
 void
 _ThreadReference(
     INOUT   PTHREAD                 Thread
-    );
+);
 
 static
 void
 _ThreadDereference(
     INOUT   PTHREAD                 Thread
-    );
+);
 
 static FUNC_FreeFunction            _ThreadDestroy;
 
@@ -128,7 +128,7 @@ void
 _ThreadKernelFunction(
     IN      PFUNC_ThreadStart       Function,
     IN_OPT  PVOID                   Context
-    );
+);
 
 static FUNC_ThreadStart     _IdleThread;
 
@@ -136,7 +136,7 @@ void
 _No_competing_thread_
 ThreadSystemPreinit(
     void
-    )
+)
 {
     memzero(&m_threadSystemData, sizeof(THREAD_SYSTEM_DATA));
 
@@ -150,7 +150,7 @@ ThreadSystemPreinit(
 STATUS
 ThreadSystemInitMainForCurrentCPU(
     void
-    )
+)
 {
     STATUS status;
     PPCPU pCpu;
@@ -165,14 +165,14 @@ ThreadSystemInitMainForCurrentCPU(
     pThread = NULL;
     pProcess = ProcessRetrieveSystemProcess();
 
-    ASSERT( NULL != pCpu );
+    ASSERT(NULL != pCpu);
 
-    snprintf( mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId );
+    snprintf(mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId);
 
     status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
     if (!SUCCEEDED(status))
     {
-        LOG_FUNC_ERROR("_ThreadInit", status );
+        LOG_FUNC_ERROR("_ThreadInit", status);
         return status;
     }
     LOGPL("_ThreadInit succeeded\n");
@@ -199,7 +199,7 @@ ThreadSystemInitMainForCurrentCPU(
 STATUS
 ThreadSystemInitIdleForCurrentCPU(
     void
-    )
+)
 {
     EX_EVENT idleStarted;
     STATUS status;
@@ -207,7 +207,7 @@ ThreadSystemInitIdleForCurrentCPU(
     char idleThreadName[MAX_PATH];
     PTHREAD idleThread;
 
-    ASSERT( INTR_OFF == CpuIntrGetState() );
+    ASSERT(INTR_OFF == CpuIntrGetState());
 
     LOG_FUNC_START_THREAD;
 
@@ -228,11 +228,11 @@ ThreadSystemInitIdleForCurrentCPU(
 
     // create idle thread
     status = ThreadCreate(idleThreadName,
-                          ThreadPriorityDefault,
-                          _IdleThread,
-                          &idleStarted,
-                          &idleThread
-                          );
+        ThreadPriorityDefault,
+        _IdleThread,
+        &idleStarted,
+        &idleThread
+    );
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("ThreadCreate", status);
@@ -262,30 +262,30 @@ ThreadSystemInitIdleForCurrentCPU(
 
 STATUS
 ThreadCreate(
-    IN_Z        char*               Name,
+    IN_Z        char* Name,
     IN          THREAD_PRIORITY     Priority,
     IN          PFUNC_ThreadStart   Function,
     IN_OPT      PVOID               Context,
-    OUT_PTR     PTHREAD*            Thread
-    )
+    OUT_PTR     PTHREAD* Thread
+)
 {
     return ThreadCreateEx(Name,
-                          Priority,
-                          Function,
-                          Context,
-                          Thread,
-                          ProcessRetrieveSystemProcess());
+        Priority,
+        Function,
+        Context,
+        Thread,
+        ProcessRetrieveSystemProcess());
 }
 
 STATUS
 ThreadCreateEx(
-    IN_Z        char*               Name,
+    IN_Z        char* Name,
     IN          THREAD_PRIORITY     Priority,
     IN          PFUNC_ThreadStart   Function,
     IN_OPT      PVOID               Context,
-    OUT_PTR     PTHREAD*            Thread,
-    INOUT       struct _PROCESS*    Process
-    )
+    OUT_PTR     PTHREAD* Thread,
+    INOUT       struct _PROCESS* Process
+)
 {
     STATUS status;
     PTHREAD pThread;
@@ -341,9 +341,9 @@ ThreadCreateEx(
     {
         // Create user-mode stack
         pThread->UserStack = MmuAllocStack(STACK_DEFAULT_SIZE,
-                                           TRUE,
-                                           FALSE,
-                                           Process);
+            TRUE,
+            FALSE,
+            Process);
         if (pThread->UserStack == NULL)
         {
             status = STATUS_MEMORY_CANNOT_BE_COMMITED;
@@ -361,8 +361,8 @@ ThreadCreateEx(
             ASSERT(Process->NumberOfThreads == 1);
 
             status = _ThreadSetupMainThreadUserStack(pThread->UserStack,
-                                                     &pThread->UserStack,
-                                                     Process);
+                &pThread->UserStack,
+                Process);
             if (!SUCCEEDED(status))
             {
                 LOG_FUNC_ERROR("_ThreadSetupUserStack", status);
@@ -371,12 +371,12 @@ ThreadCreateEx(
         }
         else
         {
-            pThread->UserStack = (PVOID) PtrDiff(pThread->UserStack, SHADOW_STACK_SIZE + sizeof(PVOID));
+            pThread->UserStack = (PVOID)PtrDiff(pThread->UserStack, SHADOW_STACK_SIZE + sizeof(PVOID));
         }
 
-        pStartFunction = (PVOID) (bProcessIniialThread ? Process->HeaderInfo->Preferred.AddressOfEntryPoint : Function);
-        firstArg       = (QWORD) (bProcessIniialThread ? Process->NumberOfArguments : (QWORD) Context);
-        secondArg      = (QWORD) (bProcessIniialThread ? PtrOffset(pThread->UserStack, SHADOW_STACK_SIZE + sizeof(PVOID)) : 0);
+        pStartFunction = (PVOID)(bProcessIniialThread ? Process->HeaderInfo->Preferred.AddressOfEntryPoint : Function);
+        firstArg = (QWORD)(bProcessIniialThread ? Process->NumberOfArguments : (QWORD)Context);
+        secondArg = (QWORD)(bProcessIniialThread ? PtrOffset(pThread->UserStack, SHADOW_STACK_SIZE + sizeof(PVOID)) : 0);
     }
     else
     {
@@ -386,15 +386,15 @@ ThreadCreateEx(
 #pragma warning(suppress:4152)
         pStartFunction = _ThreadKernelFunction;
 
-        firstArg =  (QWORD) Function;
-        secondArg = (QWORD) Context;
+        firstArg = (QWORD)Function;
+        secondArg = (QWORD)Context;
     }
 
     status = _ThreadSetupInitialState(pThread,
-                                      pStartFunction,
-                                      firstArg,
-                                      secondArg,
-                                      Process->PagingData->Data.KernelSpace);
+        pStartFunction,
+        firstArg,
+        secondArg,
+        Process->PagingData->Data.KernelSpace);
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("_ThreadSetupInitialState", status);
@@ -418,16 +418,30 @@ ThreadCreateEx(
     return status;
 }
 
+// 1. a) It is an IO bound thread because it waits for user input from the keyboard.
+//    b) It is an CPU bound thread because it is printing not logging.
+//    c) It is a CPU bound thread because it computes a sorting, thus being cpu intensive.
+//    d) It is an IO bound thread because it reads files from the disk.
+// 2. The IO bound threads should have a better response time because they deal with
+//       user interrupts.
+// 3. The CPU bound threads should have a higher running time because it is CPU intensive
+//    which means that it is used for heavy computations.
+// 4. The TickCountComplete is incremented whenever the current thread does a correct and
+//    full clock tick without being interrupted/yielded or blocked.
+//    The TickCountEarly is incremented whenever the current thread is forced to yield
+//    or to be blocked.
+// 5. I believe that IO bound threads will have higher TickCountEarly because they will 
+//    be yielded more often because they have short burst times.
 void
 ThreadTick(
     void
-    )
+)
 {
     PPCPU pCpu = GetCurrentPcpu();
     PTHREAD pThread = GetCurrentThread();
 
-    ASSERT( INTR_OFF == CpuIntrGetState());
-    ASSERT( NULL != pCpu);
+    ASSERT(INTR_OFF == CpuIntrGetState());
+    ASSERT(NULL != pCpu);
 
     LOG_TRACE_THREAD("Thread tick\n");
     if (pCpu->ThreadData.IdleThread == pThread)
@@ -450,7 +464,7 @@ ThreadTick(
 void
 ThreadYield(
     void
-    )
+)
 {
     INTR_STATE dummyState;
     INTR_STATE oldState;
@@ -458,13 +472,13 @@ ThreadYield(
     PPCPU pCpu;
     BOOLEAN bForcedYield;
 
-    ASSERT( NULL != pThread);
+    ASSERT(NULL != pThread);
 
     oldState = CpuIntrDisable();
 
     pCpu = GetCurrentPcpu();
 
-    ASSERT( NULL != pCpu );
+    ASSERT(NULL != pCpu);
 
     bForcedYield = pCpu->ThreadData.YieldOnInterruptReturn;
     pCpu->ThreadData.YieldOnInterruptReturn = FALSE;
@@ -486,7 +500,7 @@ ThreadYield(
     }
     pThread->State = ThreadStateReady;
     _ThreadSchedule();
-    ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+    ASSERT(!LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
     LOG_TRACE_THREAD("Returned from _ThreadSchedule\n");
 
     CpuIntrSetState(oldState);
@@ -495,14 +509,14 @@ ThreadYield(
 void
 ThreadBlock(
     void
-    )
+)
 {
     INTR_STATE oldState;
     PTHREAD pCurrentThread;
 
     pCurrentThread = GetCurrentThread();
 
-    ASSERT( INTR_OFF == CpuIntrGetState());
+    ASSERT(INTR_OFF == CpuIntrGetState());
     ASSERT(LockIsOwner(&pCurrentThread->BlockLock));
 
     if (THREAD_FLAG_FORCE_TERMINATE_PENDING == _InterlockedAnd(&pCurrentThread->Flags, MAX_DWORD))
@@ -515,13 +529,13 @@ ThreadBlock(
     pCurrentThread->State = ThreadStateBlocked;
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &oldState);
     _ThreadSchedule();
-    ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+    ASSERT(!LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
 }
 
 void
 ThreadUnblock(
     IN      PTHREAD              Thread
-    )
+)
 {
     INTR_STATE oldState;
     INTR_STATE dummyState;
@@ -535,14 +549,14 @@ ThreadUnblock(
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
     InsertTailList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList);
     Thread->State = ThreadStateReady;
-    LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState );
+    LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState);
     LockRelease(&Thread->BlockLock, oldState);
 }
 
 void
 ThreadExit(
     IN      STATUS              ExitStatus
-    )
+)
 {
     PTHREAD pThread;
     INTR_STATE oldState;
@@ -572,7 +586,7 @@ ThreadExit(
 BOOLEAN
 ThreadYieldOnInterrupt(
     void
-    )
+)
 {
     return GetCurrentPcpu()->ThreadData.YieldOnInterruptReturn;
 }
@@ -580,7 +594,7 @@ ThreadYieldOnInterrupt(
 void
 ThreadTakeBlockLock(
     void
-    )
+)
 {
     INTR_STATE dummyState;
 
@@ -590,11 +604,11 @@ ThreadTakeBlockLock(
 void
 ThreadWaitForTermination(
     IN      PTHREAD             Thread,
-    OUT     STATUS*             ExitStatus
-    )
+    OUT     STATUS* ExitStatus
+)
 {
-    ASSERT( NULL != Thread );
-    ASSERT( NULL != ExitStatus);
+    ASSERT(NULL != Thread);
+    ASSERT(NULL != ExitStatus);
 
     ExEventWaitForSignal(&Thread->TerminationEvt);
 
@@ -604,9 +618,9 @@ ThreadWaitForTermination(
 void
 ThreadCloseHandle(
     INOUT   PTHREAD             Thread
-    )
+)
 {
-    ASSERT( NULL != Thread);
+    ASSERT(NULL != Thread);
 
     _ThreadDereference(Thread);
 }
@@ -614,19 +628,19 @@ ThreadCloseHandle(
 void
 ThreadTerminate(
     INOUT   PTHREAD             Thread
-    )
+)
 {
-    ASSERT( NULL != Thread );
+    ASSERT(NULL != Thread);
 
     // it's not a problem if the thread already finished
-    _InterlockedOr(&Thread->Flags, THREAD_FLAG_FORCE_TERMINATE_PENDING );
+    _InterlockedOr(&Thread->Flags, THREAD_FLAG_FORCE_TERMINATE_PENDING);
 }
 
 const
 char*
 ThreadGetName(
     IN_OPT  PTHREAD             Thread
-    )
+)
 {
     PTHREAD pThread = (NULL != Thread) ? Thread : GetCurrentThread();
 
@@ -636,7 +650,7 @@ ThreadGetName(
 TID
 ThreadGetId(
     IN_OPT  PTHREAD             Thread
-    )
+)
 {
     PTHREAD pThread = (NULL != Thread) ? Thread : GetCurrentThread();
 
@@ -646,7 +660,7 @@ ThreadGetId(
 THREAD_PRIORITY
 ThreadGetPriority(
     IN_OPT  PTHREAD             Thread
-    )
+)
 {
     PTHREAD pThread = (NULL != Thread) ? Thread : GetCurrentThread();
 
@@ -656,7 +670,7 @@ ThreadGetPriority(
 void
 ThreadSetPriority(
     IN      THREAD_PRIORITY     NewPriority
-    )
+)
 {
     ASSERT(ThreadPriorityLowest <= NewPriority && NewPriority <= ThreadPriorityMaximum);
 
@@ -667,7 +681,7 @@ STATUS
 ThreadExecuteForEachThreadEntry(
     IN      PFUNC_ListFunction  Function,
     IN_OPT  PVOID               Context
-    )
+)
 {
     STATUS status;
     INTR_STATE oldState;
@@ -681,11 +695,11 @@ ThreadExecuteForEachThreadEntry(
 
     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
     status = ForEachElementExecute(&m_threadSystemData.AllThreadsList,
-                                   Function,
-                                   Context,
-                                   FALSE
-                                   );
-    LockRelease(&m_threadSystemData.AllThreadsLock, oldState );
+        Function,
+        Context,
+        FALSE
+    );
+    LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
 
     return status;
 }
@@ -693,7 +707,7 @@ ThreadExecuteForEachThreadEntry(
 void
 SetCurrentThread(
     IN      PTHREAD     Thread
-    )
+)
 {
     PPCPU pCpu;
 
@@ -707,18 +721,18 @@ SetCurrentThread(
     {
         pCpu->StackTop = Thread->InitialStackBase;
         pCpu->StackSize = Thread->StackSize;
-        pCpu->Tss.Rsp[0] = (QWORD) Thread->InitialStackBase;
+        pCpu->Tss.Rsp[0] = (QWORD)Thread->InitialStackBase;
     }
 }
 
 static
 STATUS
 _ThreadInit(
-    IN_Z        char*               Name,
+    IN_Z        char* Name,
     IN          THREAD_PRIORITY     Priority,
-    OUT_PTR     PTHREAD*            Thread,
+    OUT_PTR     PTHREAD* Thread,
     IN          BOOLEAN             AllocateKernelStack
-    )
+)
 {
     STATUS status;
     PTHREAD pThread;
@@ -731,7 +745,7 @@ _ThreadInit(
     ASSERT(NULL != Name);
     ASSERT(NULL != Thread);
     ASSERT_INFO(ThreadPriorityLowest <= Priority && Priority <= ThreadPriorityMaximum,
-                "Priority is 0x%x\n", Priority);
+        "Priority is 0x%x\n", Priority);
 
     status = STATUS_SUCCESS;
     pThread = NULL;
@@ -780,10 +794,10 @@ _ThreadInit(
             pThread->StackSize = STACK_DEFAULT_SIZE;
         }
 
-        pThread->Name = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(char)*(nameLen + 1), HEAP_THREAD_TAG, 0);
+        pThread->Name = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(char) * (nameLen + 1), HEAP_THREAD_TAG, 0);
         if (NULL == pThread->Name)
         {
-            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(char)*(nameLen + 1));
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(char) * (nameLen + 1));
             status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
             __leave;
         }
@@ -854,29 +868,29 @@ _ThreadSetupInitialState(
     IN      QWORD               FirstArgument,
     IN      QWORD               SecondArgument,
     IN      BOOLEAN             KernelStack
-    )
+)
 {
     STATUS status;
     PVOID* pStack;
     PCOMPLETE_PROCESSOR_STATE pState;
     PINTERRUPT_STACK pIst;
 
-    ASSERT( NULL != Thread );
-    ASSERT( NULL != StartFunction);
+    ASSERT(NULL != Thread);
+    ASSERT(NULL != StartFunction);
 
     status = STATUS_SUCCESS;
 
-    pStack = (PVOID*) Thread->Stack;
+    pStack = (PVOID*)Thread->Stack;
 
     // The kernel function has to have a shadow space and a dummy RA
-    pStack = pStack - ( 4 + 1 );
+    pStack = pStack - (4 + 1);
 
-    pStack = (PVOID*) PtrDiff(pStack, sizeof(INTERRUPT_STACK));
+    pStack = (PVOID*)PtrDiff(pStack, sizeof(INTERRUPT_STACK));
 
     // setup pseudo-interrupt stack
-    pIst = (PINTERRUPT_STACK) pStack;
+    pIst = (PINTERRUPT_STACK)pStack;
 
-    pIst->Rip = (QWORD) StartFunction;
+    pIst->Rip = (QWORD)StartFunction;
     if (KernelStack)
     {
         pIst->CS = GdtMuGetCS64Supervisor();
@@ -888,7 +902,7 @@ _ThreadSetupInitialState(
         ASSERT(Thread->UserStack != NULL);
 
         pIst->CS = GdtMuGetCS64Usermode() | RING_THREE_PL;
-        pIst->Rsp = (QWORD) Thread->UserStack;
+        pIst->Rsp = (QWORD)Thread->UserStack;
         pIst->SS = GdtMuGetDS64Usermode() | RING_THREE_PL;
     }
 
@@ -898,10 +912,10 @@ _ThreadSetupInitialState(
 
     // warning C4054: 'type cast': from function pointer 'void (__cdecl *)(const PFUNC_ThreadStart,const PVOID)' to data pointer 'PVOID'
 #pragma warning(suppress:4054)
-    *pStack = (PVOID) ThreadStart;
+    * pStack = (PVOID)ThreadStart;
 
-    pStack = (PVOID*) PtrDiff(pStack, sizeof(COMPLETE_PROCESSOR_STATE));
-    pState = (PCOMPLETE_PROCESSOR_STATE) pStack;
+    pStack = (PVOID*)PtrDiff(pStack, sizeof(COMPLETE_PROCESSOR_STATE));
+    pState = (PCOMPLETE_PROCESSOR_STATE)pStack;
 
     memzero(pState, sizeof(COMPLETE_PROCESSOR_STATE));
     pState->RegisterArea.RegisterValues[RegisterRcx] = FirstArgument;
@@ -942,9 +956,9 @@ static
 STATUS
 _ThreadSetupMainThreadUserStack(
     IN      PVOID               InitialStack,
-    OUT     PVOID*              ResultingStack,
+    OUT     PVOID* ResultingStack,
     IN      PPROCESS            Process
-    )
+)
 {
     ASSERT(InitialStack != NULL);
     ASSERT(ResultingStack != NULL);
@@ -961,7 +975,7 @@ static
 void
 _ThreadSchedule(
     void
-    )
+)
 {
     PTHREAD pCurrentThread;
     PTHREAD pNextThread;
@@ -971,7 +985,7 @@ _ThreadSchedule(
     ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
 
     pCurrentThread = GetCurrentThread();
-    ASSERT( NULL != pCurrentThread );
+    ASSERT(NULL != pCurrentThread);
 
     pCpu = GetCurrentPcpu();
 
@@ -980,7 +994,7 @@ _ThreadSchedule(
 
     // get next thread
     pNextThread = _ThreadGetReadyThread();
-    ASSERT( NULL != pNextThread );
+    ASSERT(NULL != pNextThread);
 
     // if current differs from next
     // => schedule next
@@ -1001,7 +1015,7 @@ _ThreadSchedule(
         pCurrentThread->UninterruptedTicks = 0;
 
         SetCurrentThread(pNextThread);
-        ThreadSwitch( &pCurrentThread->Stack, pNextThread->Stack);
+        ThreadSwitch(&pCurrentThread->Stack, pNextThread->Stack);
 
         ASSERT(INTR_OFF == CpuIntrGetState());
         ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
@@ -1032,7 +1046,7 @@ RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_threadSystemData.ReadyThreadsLock)
 void
 ThreadCleanupPostSchedule(
     void
-    )
+)
 {
     PTHREAD prevThread;
 
@@ -1052,7 +1066,7 @@ ThreadCleanupPostSchedule(
             // it was previously holding the block hold, it may have been preempted before
             // acquiring it.
             ASSERT(prevThread->State == ThreadStateBlocked
-                   || prevThread == GetCurrentPcpu()->ThreadData.IdleThread);
+                || prevThread == GetCurrentPcpu()->ThreadData.IdleThread);
 
             LOG_TRACE_THREAD("Will release block lock for thread [%s]\n", prevThread->Name);
 
@@ -1080,9 +1094,9 @@ STATUS
 
     LOG_FUNC_START_THREAD;
 
-    ASSERT( NULL != Context);
+    ASSERT(NULL != Context);
 
-    pEvent = (PEX_EVENT) Context;
+    pEvent = (PEX_EVENT)Context;
     ExEventSignal(pEvent);
 
     // warning C4127: conditional expression is constant
@@ -1105,14 +1119,14 @@ _Ret_notnull_
 PTHREAD
 _ThreadGetReadyThread(
     void
-    )
+)
 {
     PTHREAD pNextThread;
     PLIST_ENTRY pEntry;
     BOOLEAN bIdleScheduled;
 
-    ASSERT( INTR_OFF == CpuIntrGetState());
-    ASSERT( LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+    ASSERT(INTR_OFF == CpuIntrGetState());
+    ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
 
     pNextThread = NULL;
 
@@ -1124,9 +1138,9 @@ _ThreadGetReadyThread(
     }
     else
     {
-        pNextThread = CONTAINING_RECORD( pEntry, THREAD, ReadyList );
+        pNextThread = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
 
-        ASSERT( pNextThread->State == ThreadStateReady );
+        ASSERT(pNextThread->State == ThreadStateReady);
         bIdleScheduled = FALSE;
     }
 
@@ -1142,11 +1156,11 @@ static
 void
 _ThreadForcedExit(
     void
-    )
+)
 {
     PTHREAD pCurrentThread = GetCurrentThread();
 
-    _InterlockedOr( &pCurrentThread->Flags, THREAD_FLAG_FORCE_TERMINATED );
+    _InterlockedOr(&pCurrentThread->Flags, THREAD_FLAG_FORCE_TERMINATED);
 
     ThreadExit(STATUS_JOB_INTERRUPTED);
     NOT_REACHED;
@@ -1156,9 +1170,9 @@ static
 void
 _ThreadReference(
     INOUT   PTHREAD                 Thread
-    )
+)
 {
-    ASSERT( NULL != Thread );
+    ASSERT(NULL != Thread);
 
     RfcReference(&Thread->RefCnt);
 }
@@ -1167,9 +1181,9 @@ static
 void
 _ThreadDereference(
     INOUT   PTHREAD                 Thread
-    )
+)
 {
-    ASSERT( NULL != Thread );
+    ASSERT(NULL != Thread);
 
     RfcDereference(&Thread->RefCnt);
 }
@@ -1179,10 +1193,10 @@ void
 _ThreadDestroy(
     IN      PVOID                   Object,
     IN_OPT  PVOID                   Context
-    )
+)
 {
     INTR_STATE oldState;
-    PTHREAD pThread = (PTHREAD) CONTAINING_RECORD(Object, THREAD, RefCnt);
+    PTHREAD pThread = (PTHREAD)CONTAINING_RECORD(Object, THREAD, RefCnt);
 
     ASSERT(NULL != pThread);
     ASSERT(NULL == Context);
@@ -1225,7 +1239,7 @@ void
 _ThreadKernelFunction(
     IN      PFUNC_ThreadStart       Function,
     IN_OPT  PVOID                   Context
-    )
+)
 {
     STATUS exitStatus;
 
